import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import matplotlib.patches as patches
from matplotlib.patches import Polygon, Wedge
import random
from PIL import Image

GRID_SIZE = 50
NUM_wolf = 10
NUM_rabbit = 20
Hunting_skill_average = 0.8
food_counter_wolf = 3 #amount of food that wolf needs to eat to make new wolf (and to be alive)
WOLF_STARVE_LIMIT = 3 #amount of days wolf can live without food
food_counter_rabbit = 20 #amount of food that rabbit needs to eat to make new rabbit (and to be alive)
Starting_amount_rabbits_in_house = 2 #amount of rabbits that are in one house in the beginning of run
rabbit_sight_radius = 4 #from what distance rabbit can see wolf
wolf_sight_radius = 5 #from what distance wolf can see rabbit
Home_wolf_size = 15 #size of a house of wolfs
Pack_radius = 2 #How near wolfs need to be to reproduce (and to eat rabbit, because I`m to lazy to make another one)

wolf_img = Image.new('RGB', (1, 1), color = 'red') # 1x1 pixel red square
rabbit_img = Image.new('RGB', (1, 1), color = 'blue') # 1x1 pixel blue square
home_rabbit_img = Image.new('RGB', (1, 1), color = 'black') # 1x1 pixel white square
home_wolf_img = Image.new('RGB', (1, 1), color = 'gray') 
# Should be able to see throug color of wolf home

class Agent:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class home_rabbit(Agent):
    def __init__(self, x, y):
        super().__init__(x, y)
#    def check(self, rabbit):

class home_wolf(Agent):
    def __init__(self, x, y):
        super().__init__(x, y)

class wolf(Agent):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.speed = np.clip(np.random.normal(Hunting_skill_average, 0.1), 0.1, 0.9)
        self.food_counter = 0
        self.hunger = 0
    def move(self, rabbits, wolfs, home_wolf_location, width, height):
        self.hunger += 1
        #check for distance from home
        dist_home_wolf = np.sqrt((self.x - home_wolf_location[0].x)**2 + (self.y - home_wolf_location[0].y)**2)
        if (self.food_counter < food_counter_wolf):
            #check if wolf is in or outside home and move if so
            if (dist_home_wolf < Home_wolf_size):
                dx = self.x - home_wolf_location[0].x
                dy = self.y - home_wolf_location[0].y
                move_x = 2 if dx > 0 else -2 if dx < 0 else 0
                move_y = 2 if dy > 0 else -2 if dy < 0 else 0

                self.x = (self.x + move_x) % width
                self.y = (self.y + move_y) % height
            else:
                # ignore rabbits that are hiding in their own home
                huntable = [r for r in rabbits if not (r.x == r.My_home_x and r.y == r.My_home_y)]

                if not huntable:
                # no huntable rabbits -> wander
                    self.x = (self.x + random.choice([-2, 0, 2])) % width
                    self.y = (self.y + random.choice([-2, 0, 2])) % height
                    return
                
                #cheking for nearest rabbit
                nearest_rabbit = min(huntable, key=lambda r: (self.x - r.x)**2 + (self.y - r.y)**2)
                if (np.sqrt((self.x - nearest_rabbit.x)**2 + (self.y - nearest_rabbit.y)**2) > wolf_sight_radius):
                    #move randomly if there is no rabbits in sight
                    self.x = (self.x + random.choice([-2, 0, 2])) % width
                    self.y = (self.y + random.choice([-2, 0, 2])) % height
                else:
                    #trying to catch rabbit
                    dx = nearest_rabbit.x - self.x
                    dy = nearest_rabbit.y - self.y
                
                    move_x = 2 if dx > 0 else -2 if dx < 0 else 0
                    move_y = 2 if dy > 0 else -2 if dy < 0 else 0

                    self.x = (self.x + move_x) % width
                    self.y = (self.y + move_y) % height
            
        else:
            #moving in direction of home
            dx = self.x - home_wolf_location[0].x
            dy = self.y - home_wolf_location[0].y
            move_x = 2 if dx < 0 else -2 if dx > 0 else 0
            move_y = 2 if dy < 0 else -2 if dy > 0 else 0

            self.x = (self.x + move_x) % width
            self.y = (self.y + move_y) % height


class rabbit(Agent):
    def __init__(self, x, y):
        super().__init__(x,y)
        self.food_counter = 0
        self.Have_House = False
        self.My_home_x = None
        self.My_home_y = None
    def move(self, wolfs, homes_rabbit, width, height):
        # 1) If rabbit has no home yet, assign one ONCE (nearest home)
        if self.My_home_x is None and homes_rabbit:
            nearest_home = min(
                homes_rabbit,
                key=lambda h: (self.x - h.x)**2 + (self.y - h.y)**2
            )
            self.My_home_x, self.My_home_y = nearest_home.x, nearest_home.y
            self.Have_House = True

        # 2) Scan for nearby wolves
        nearby_wolfs = []
        for w in wolfs:
            dist = np.sqrt((self.x - w.x)**2 + (self.y - w.y)**2)
            if dist < rabbit_sight_radius:
                nearby_wolfs.append(w)

        # 3) Decide next position (nx, ny)
        if nearby_wolfs and self.My_home_x is not None:
            # Run toward home
            dx = self.My_home_x - self.x
            dy = self.My_home_y - self.y
            step_x = 1 if dx > 0 else -1 if dx < 0 else 0
            step_y = 1 if dy > 0 else -1 if dy < 0 else 0
            nx = (self.x + step_x) % width
            ny = (self.y + step_y) % height
        else:
            # Wander randomly
            nx = (self.x + random.choice([-1, 0, 1])) % width
            ny = (self.y + random.choice([-1, 0, 1])) % height

            # Gain food only while wandering and not already "full"
            if self.food_counter <= food_counter_rabbit:
                if not (nx == self.My_home_x and ny == self.My_home_y):
                    self.food_counter += 1


        # 4) Apply movement
        self.x, self.y = nx, ny

        # 5) If rabbit is "full", it tends to return home 
        if self.food_counter > food_counter_rabbit and self.My_home_x is not None:
            dx = self.My_home_x - self.x
            dy = self.My_home_y - self.y
            step_x = 1 if dx > 0 else -1 if dx < 0 else 0
            step_y = 1 if dy > 0 else -1 if dy < 0 else 0
            self.x = (self.x + step_x) % width
            self.y = (self.y + step_y) % height



def draw_wolf(ax, x, y, food_counter, hunger):
    """ÐœÐ°Ð»ÑŽÑ” Ð²Ð¾Ð»ÐºÐ° ÑÐº Ñ‚Ñ€Ð¸ÐºÑƒÑ‚Ð½Ð¸Ðº (Ð³Ð¾Ð»Ð¾Ð²Ð° Ð½Ð°Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð°)"""
    hunger_ratio = min(hunger / WOLF_STARVE_LIMIT, 1.0)
    
    if hunger_ratio > 0.7:
        body_color = '#A9A9A9'
        head_color = '#C0C0C0'
    else:
        food_ratio = min(food_counter / food_counter_wolf, 1.0)
        intensity = 0.4 + food_ratio * 0.3
        body_color = (intensity, intensity, intensity)
        head_color = (intensity + 0.1, intensity + 0.1, intensity + 0.1)
    
    body = Polygon([
        [x - 0.35, y - 0.25],
        [x + 0.35, y - 0.25],
        [x + 0.15, y + 0.35],
        [x - 0.15, y + 0.35]
    ], color=body_color, edgecolor='#696969', linewidth=1.2, alpha=0.95)
    ax.add_patch(body)
    
    head = Polygon([
        [x - 0.2, y + 0.35],
        [x + 0.2, y + 0.35],
        [x, y + 0.55]
    ], color=head_color, edgecolor='#696969', linewidth=1.2, alpha=0.95)
    ax.add_patch(head)
    
    ear_left = Polygon([
        [x - 0.15, y + 0.45],
        [x - 0.12, y + 0.65],
        [x - 0.05, y + 0.5]
    ], color=body_color, edgecolor='#696969', linewidth=0.8, alpha=0.95)
    ax.add_patch(ear_left)
    
    ear_right = Polygon([
        [x + 0.15, y + 0.45],
        [x + 0.12, y + 0.65],
        [x + 0.05, y + 0.5]
    ], color=body_color, edgecolor='#696969', linewidth=0.8, alpha=0.95)
    ax.add_patch(ear_right)

def draw_rabbit(ax, x, y, food_level):
    """ÐœÐ°Ð»ÑŽÑ” Ð·Ð°Ð¹Ñ†Ñ ÑÐº ÐºÐ¾Ð»Ð¾ Ð· Ð²ÑƒÑˆÐ°Ð¼Ð¸"""
    food_ratio = min(food_level / food_counter_rabbit, 1.0)
    
    base_color = 0.8 + food_ratio * 0.2
    rabbit_color = (base_color, base_color - 0.1, base_color - 0.2)
    
    body = plt.Circle((x, y), 0.35, color=rabbit_color, alpha=0.95, edgecolor='#8B7355', linewidth=1)
    ax.add_patch(body)
    
    ear_left = plt.Circle((x - 0.15, y + 0.5), 0.15, color=rabbit_color, alpha=0.95, edgecolor='#8B7355', linewidth=0.8)
    ax.add_patch(ear_left)
    
    ear_right = plt.Circle((x + 0.15, y + 0.5), 0.15, color=rabbit_color, alpha=0.95, edgecolor='#8B7355', linewidth=0.8)
    ax.add_patch(ear_right)
    
    inner_left = plt.Circle((x - 0.15, y + 0.5), 0.08, color='#DEB887', alpha=0.8)
    ax.add_patch(inner_left)
    
    inner_right = plt.Circle((x + 0.15, y + 0.5), 0.08, color='#DEB887', alpha=0.8)
    ax.add_patch(inner_right)

def draw_rabbit_home(ax, x, y):
    """ÐœÐ°Ð»ÑŽÑ” ÐºÐ¾Ñ€Ð¸Ñ‡Ð½ÐµÐ²Ñƒ Ð½Ð¾Ñ€ÐºÑƒ"""
    home = Wedge((x, y), 0.9, 0, 180, color='#8B4513', alpha=0.7, edgecolor='#654321', linewidth=2)
    ax.add_patch(home)
    
    shadow = Wedge((x, y), 0.75, 0, 180, color='#654321', alpha=0.5, edgecolor='none')
    ax.add_patch(shadow)

def draw_wolf_den(ax, x, y):
    """ÐœÐ°Ð»ÑŽÑ” Ð¿ÐµÑ‰ÐµÑ€Ñƒ Ð´Ð»Ñ Ð²Ð¾Ð»ÐºÑ–Ð²"""
    cave = Wedge((x, y), 1.2, 0, 180, color='#708090', alpha=0.75, edgecolor='#2F4F4F', linewidth=2.5)
    ax.add_patch(cave)
    
    cave_shadow = Wedge((x, y), 1.0, 0, 180, color='#2F4F4F', alpha=0.6, edgecolor='none')
    ax.add_patch(cave_shadow)
    
    stone1 = Polygon([
        [x - 0.6, y + 0.15],
        [x - 0.8, y + 0.05],
        [x - 0.7, y - 0.1]
    ], color='#696969', alpha=0.7, edgecolor='#2F4F4F', linewidth=1)
    ax.add_patch(stone1)
    
    stone2 = Polygon([
        [x + 0.6, y + 0.15],
        [x + 0.8, y + 0.05],
        [x + 0.7, y - 0.1]
    ], color='#696969', alpha=0.7, edgecolor='#2F4F4F', linewidth=1)
    ax.add_patch(stone2)



c_x = GRID_SIZE // 2
c_y = GRID_SIZE // 2

lower_wolf_house = round(c_x - Home_wolf_size)
upper_wolf_house = round(c_y + Home_wolf_size)


home_wolf_location = [home_wolf(round(GRID_SIZE/2),round(GRID_SIZE/2)) for _ in range(1)]
wolfs = [wolf(random.randint(lower_wolf_house, upper_wolf_house), random.randint(lower_wolf_house, upper_wolf_house)) for _ in range(NUM_wolf)]

def spawn_far_from(cx, cy, Home_wolf_size):
    while True:
        x = random.randint(0, GRID_SIZE - 1)
        y = random.randint(0, GRID_SIZE - 1)
        if abs(x - cx) + abs(y - cy) >= Home_wolf_size:   # manhattan distance
            return x, y

NUM_RABBIT_HOMES = NUM_rabbit // Starting_amount_rabbits_in_house
homes_rabbit = []
for _ in range(NUM_RABBIT_HOMES):
    hx, hy = spawn_far_from(c_x, c_y, Home_wolf_size)
    homes_rabbit.append(home_rabbit(hx, hy))
rabbits = []
base = NUM_rabbit // NUM_RABBIT_HOMES
extra = NUM_rabbit % NUM_RABBIT_HOMES
#Spawn rabbits evenly
for idx, h in enumerate(homes_rabbit):
    count = base + (1 if idx < extra else 0)
    for _ in range(count):
        x, y = h.x, h.y
        rb = rabbit(x, y)
        rb.My_home_x, rb.My_home_y = h.x, h.y
        rabbits.append(rb)

def update(frame):
    global wolfs, rabbits, homes_rabbit, home_wolf_location


    home_cells = set((h.x, h.y) for h in homes_rabbit)

    #1 Movement
    for w in wolfs:
        w.move(rabbits, wolfs, home_wolf_location, GRID_SIZE, GRID_SIZE)
    for r in rabbits:
        r.move(wolfs, homes_rabbit, GRID_SIZE, GRID_SIZE)
    
    #NEADS TO BE DONE
    
    # Interaction 
    eaten = set()
    
    for w in wolfs:
        for i, r in enumerate(rabbits):
            if abs(w.x - r.x) + abs(w.y - r.y) <= Pack_radius:
                if r.My_home_x == r.x and r.My_home_y == r.y:
                    continue
                eaten.add(i)
                w.food_counter += 1
                w.hunger = 0
                break
    
    if eaten:
        rabbits = [r for i, r in enumerate(rabbits) if i not in eaten]
        
    #Reproduction
    newborn_rabbits = []
    for r in rabbits:
        if r.food_counter >= food_counter_rabbit:
            r.food_counter -= food_counter_rabbit
            h = random.choice(homes_rabbit)
            bx, by = h.x, h.y
            baby = rabbit(bx, by)
            baby.My_home_x, baby.My_home_y = h.x, h.y
            baby.Have_House = True
            newborn_rabbits.append(baby)
    rabbits.extend(newborn_rabbits)
    
    # Wolves reproduce near home when two FULL wolves are neighbors
    hx, hy = home_wolf_location[0].x, home_wolf_location[0].y
    newborn_wolves = []
    used = set()

    for i in range(len(wolfs)):
        if i in used:
            continue
        w1 = wolfs[i]

        # must be full and in home zone
        if w1.food_counter < food_counter_wolf:
            continue
        if abs(w1.x - hx) + abs(w1.y - hy) > Home_wolf_size:
            continue

        # find partner
        for j in range(i + 1, len(wolfs)):
            if j in used:
                continue
            w2 = wolfs[j]

            if w2.food_counter < food_counter_wolf:
                    continue
            if abs(w2.x - hx) + abs(w2.y - hy) > Home_wolf_size:
                continue

            # meet = neighbor 
            if abs(w1.x - w2.x) + abs(w1.y - w2.y) <= Pack_radius:
                # parents spend food to reproduce
                w1.food_counter -= food_counter_wolf
                w2.food_counter -= food_counter_wolf

              
                bx = hx + random.randint(-3, 3)
                by = hy + random.randint(-3, 3)
                bx = max(0, min(GRID_SIZE - 1, bx))
                by = max(0, min(GRID_SIZE - 1, by))
                newborn_wolves.append(wolf(bx, by))


                used.add(i)
                used.add(j)
                break

    wolfs.extend(newborn_wolves)     
    
    #starvation for wolfs
    wolfs = [w for w in wolfs if w.hunger < WOLF_STARVE_LIMIT]

    ax.clear()
    
    grid = np.zeros((GRID_SIZE, GRID_SIZE, 3))
    for i in range(GRID_SIZE):
        for j in range(GRID_SIZE):
            green_base = 0.3 + (i / GRID_SIZE) * 0.15
            green_var = 0.2 + (j / GRID_SIZE) * 0.2
            grid[i, j] = [0.1 + green_base * 0.1, green_base + green_var * 0.1, 0.05 + green_base * 0.05]
    
    ax.imshow(grid, origin='lower', extent=[0, GRID_SIZE, 0, GRID_SIZE])
    
    for h in homes_rabbit:
        draw_rabbit_home(ax, h.x, h.y)
    
    wh = home_wolf_location[0]
    draw_wolf_den(ax, wh.x, wh.y)
    
    for r in rabbits:
        draw_rabbit(ax, r.x, r.y, r.food_counter)
    
    for w in wolfs:
        draw_wolf(ax, w.x, w.y, w.food_counter, w.hunger)
    
    stats_text = f'Frame: {frame} | Wolves: {len(wolfs)} | Rabbits: {len(rabbits)}'
    ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, 
            fontsize=11, verticalalignment='top',
            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8),
            color='#2F4F4F', weight='bold', family='monospace')
    
    ax.set_xlim(0, GRID_SIZE)
    ax.set_ylim(0, GRID_SIZE)
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.15, color='white', linestyle='--', linewidth=0.5)
    ax.set_xlabel('X ÐšÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ð°', fontsize=10, color='white')
    ax.set_ylabel('Y ÐšÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ð°', fontsize=10, color='white')
    ax.set_title('Ð¡Ð¸Ð¼ÑƒÐ»ÑÑ†Ñ–Ñ: Ð’Ð¾Ð²ÐºÐ¸ ðŸº Ñ‚Ð° ÐšÑ€Ð¾Ð»Ð¸ÐºÐ¸ ðŸ°', fontsize=14, weight='bold', color='white', pad=15)
    
    ax.set_facecolor('#1a1a2e')
    fig.patch.set_facecolor('#0f3460')

# Create animation
fig, ax = plt.subplots(figsize=(14, 10), facecolor='#0f3460')

# Create animation with smooth updates
ani = animation.FuncAnimation(fig, update, frames=2000, interval=50, repeat=True, repeat_delay=2000)

# Add legend
from matplotlib.patches import Patch
legend_elements = [
    Patch(facecolor='#708090', edgecolor='#2F4F4F', label='ðŸº Ð’Ð¾Ð²ÐºÐ¸ (ÑÑ–Ñ€Ñ–, Ð¿ÐµÑ‰ÐµÑ€Ð°)'),
    Patch(facecolor='#DEB887', edgecolor='#8B7355', label='ðŸ° ÐšÑ€Ð¾Ð»Ð¸ÐºÐ¸ (Ð±ÐµÐ¶ÐµÐ²Ñ–, Ð½Ð¾Ñ€ÐºÐ° ÐºÐ¾Ñ€Ð¸Ñ‡Ð½ÐµÐ²Ð°)'),
]
ax.legend(handles=legend_elements, loc='upper left', fontsize=10, 
          framealpha=0.95, facecolor='#2F4F4F', edgecolor='white', labelcolor='white')

plt.tight_layout()
plt.show()





    
