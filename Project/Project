import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import random
from PIL import Image

GRID_SIZE = 50
NUM_wolf = 10
NUM_rabbit = 20
Hunting_skill_average = 0.8
food_counter_wolf = 5 #amount of food that wolf needs to eat to make new wolf (and to be alive)
WOLF_STARVE_LIMIT = 20 #amount of days wolf can live without food
food_counter_rabbit = 20 #amount of food that rabbit needs to eat to make new rabbit (and to be alive)
Starting_amount_rabbits_in_house = 2 #amount of rabbits that are in one house in the begining of run
rabbit_sight_radius = 4 #from what distance rabbit can see wolf
wolf_sight_radius = 5 #from what distance wolf can see rabbit
Home_wolf_size = 15 #size of a house of wolfs
Pack_radius = 2 #How near wolfs need to be to reproduce (and to eat rabbit, because I`m to lazy to make another one)

wolf_img = Image.new('RGB', (1, 1), color = 'red') # 1x1 pixel red square
rabbit_img = Image.new('RGB', (1, 1), color = 'blue') # 1x1 pixel blue square
home_rabbit_img = Image.new('RGB', (1, 1), color = 'black') # 1x1 pixel white square
home_wolf_img = Image.new('RGB', (1, 1), color = 'gray') 
# Should be able to see throug color of wolf home

class Agent:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class home_rabbit(Agent):
    def __init__(self, x, y):
        super().__init__(x, y)
#    def check(self, rabbit):
# needs to check if there is two rabbits in home, if it is true no more rabbits allowed
class home_wolf(Agent):
    def __init__(self, x, y):
        super().__init__(x, y)

class wolf(Agent):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.speed = np.clip(np.random.normal(Hunting_skill_average, 0.1), 0.1, 0.9)
        self.food_counter = 0
        self.hunger = 0
    def move(self, rabbits, wolfs, home_wolf_location, width, height):
        #check for distance from home
        dist_home_wolf = np.sqrt((self.x - home_wolf_location[0].x)**2 + (self.y - home_wolf_location[0].y)**2)
        if (self.food_counter <= food_counter_wolf):
            #check if wolf is in or outside home and move if so
            if (dist_home_wolf < Home_wolf_size):
                dx = self.x - home_wolf_location[0].x
                dy = self.y - home_wolf_location[0].y
                move_x = 2 if dx > 0 else -2 if dx < 0 else 0
                move_y = 2 if dy > 0 else -2 if dy < 0 else 0

                self.x = (self.x + move_x) % width
                self.y = (self.y + move_y) % height
            else:
                #cheking for nearest rabbit
                nearest_rabbit = min(rabbits, key=lambda r: (self.x - r.x)**2 + (self.y - r.y)**2)
                if (np.sqrt((self.x - nearest_rabbit.x)**2 + (self.y - nearest_rabbit.y)**2) > wolf_sight_radius):
                    #move randomly if there is no rabbits in sight
                    self.x = (self.x + random.choice([-2, 0, 2])) % width
                    self.y = (self.y + random.choice([-2, 0, 2])) % height
                else:
                    #trying to catch rabbit
                    dx = nearest_rabbit.x - self.x
                    dy = nearest_rabbit.y - self.y
                
                    move_x = 2 if dx > 0 else -2 if dx < 0 else 0
                    move_y = 2 if dy > 0 else -2 if dy < 0 else 0

                    self.x = (self.x + move_x) % width
                    self.y = (self.y + move_y) % height
            self.hunger += 1
        else:
            #moving in direction of home
            dx = self.x - home_wolf_location[0].x
            dy = self.y - home_wolf_location[0].y
            move_x = 2 if dx < 0 else -2 if dx > 0 else 0
            move_y = 2 if dy < 0 else -2 if dy > 0 else 0

            self.x = (self.x + move_x) % width
            self.y = (self.y + move_y) % height


class rabbit(Agent):
    def __init__(self, x, y):
        super().__init__(x,y)
        self.food_counter = 0
        self.Have_House = False
        self.My_home_x = 1
        self.My_home_y = 1
    def move(self, wolfs, homes_rabbit, width, height):
        if (self.food_counter <= food_counter_rabbit):
            for h in homes_rabbit:
                #moving outside of house and saving it as my house
                if (self.x == h.x) and (self.y == h.y):
                    self.My_home_x = h.x
                    self.My_home_y = h.y
                    self.Have_House = True
                    self.x = (self.x + random.choice([-1, 0, 1])) % width
                    self.y = (self.y + random.choice([-1, 0, 1])) % height
                    self.food_counter +=1
                else:
                    #cheaking for nearby wolfs
                    nearby_wolfs = []
                    for w in wolfs:
                        dist = np.sqrt((self.x - w.x)**2 + (self.y - w.y)**2)
                        if (dist < rabbit_sight_radius):
                            nearby_wolfs.append(w)
                    if nearby_wolfs:
                        if nearby_wolfs and self.My_home_x is not None:
                            dx = self.My_home_x - self.x
                            dy = self.My_home_y - self.y
                            move_x = 1 if dx > 0 else -1 if dx < 0 else 0
                            move_y = 1 if dy > 0 else -1 if dy < 0 else 0
                        else:
                            move_x = (self.x + random.choice([-1, 0, 1])) % width
                            move_y = (self.y + random.choice([-1, 0, 1])) % height
                    else:
                        #moving randomly
                        self.x = (self.x + random.choice([-1, 0, 1])) % width
                        self.y = (self.y + random.choice([-1, 0, 1])) % height
                        self.food_counter +=1
        else:
            dx = self.My_home_x - self.x
            dy = self.My_home_y - self.y

            move_x = 1 if dx > 0 else -1 if dx < 0 else 0
            move_y = 1 if dy > 0 else -1 if dy < 0 else 0

            self.x = (self.x + move_x) % width
            self.y = (self.y + move_y) % height



c_x = GRID_SIZE // 2
c_y = GRID_SIZE // 2

lower_wolf_house = round(c_x - Home_wolf_size)
upper_wolf_house = round(c_y + Home_wolf_size)


home_wolf_location = [home_wolf(round(GRID_SIZE/2),round(GRID_SIZE/2)) for _ in range(1)]
wolfs = [wolf(random.randint(lower_wolf_house, upper_wolf_house), random.randint(lower_wolf_house, upper_wolf_house)) for _ in range(NUM_wolf)]

def spawn_far_from(cx, cy, Home_wolf_size):
    while True:
        x = random.randint(0, GRID_SIZE - 1)
        y = random.randint(0, GRID_SIZE - 1)
        if abs(x - cx) + abs(y - cy) >= Home_wolf_size:   # manhattan distance
            return x, y

NUM_RABBIT_HOMES = NUM_rabbit // Starting_amount_rabbits_in_house
homes_rabbit = []
for _ in range(NUM_RABBIT_HOMES):
    hx, hy = spawn_far_from(c_x, c_y, Home_wolf_size)
    homes_rabbit.append(home_rabbit(hx, hy))
rabbits = []
base = NUM_rabbit // NUM_RABBIT_HOMES
extra = NUM_rabbit % NUM_RABBIT_HOMES
#Spawn rabbits evenly
for idx, h in enumerate(homes_rabbit):
    count = base + (1 if idx < extra else 0)
    for _ in range(count):
        x, y = h.x, h.y
        rb = rabbit(x, y)
        rb.home_x, rb.home_y = h.x, h.y
        rabbits.append(rb)

def update(frame):
    global wolfs, rabbits, homes_rabbit, home_wolf_location

    #Needed for avoiding overlaps
    rabbit_cells = set((r.x, r.y) for r in rabbits)
    wolf_cells = set((w.x, w.y) for w in wolfs)
    home_cells = set((h.x, h.y) for h in homes_rabbit)

    #1 Movement
    for w in wolfs:
        w.move(rabbits, wolfs, home_wolf_location, GRID_SIZE, GRID_SIZE)
    for r in rabbits:
        r.move(wolfs, homes_rabbit, GRID_SIZE, GRID_SIZE)
    
    #NEADS TO BE DONE
    
    # Interaction 
    eaten = set()
    
    for w in wolfs:
        for i, r in enumerate(rabbits):
            if abs(w.x - r.x) + abs(w.y - r.y) <= Pack_radius:
                if (r.x, r.y) in home_cells:
                    continue
                eaten.add(i)
                w.food_counter += 1
                w.hunger = 0
                break
    
    if eaten:
        rabbits = [r for i, r in enumerate(rabbits) if i not in eaten]
        
    #Reproduction
    newborn_rabbits = []
    for r in rabbits:
        if r.food_counter >= food_counter_rabbit:
            r.food_counter -= food_counter_rabbit
            h = random.choice(homes_rabbit)
            bx, by = h.x, h.y
            baby = rabbit(bx, by)
            baby.home_x, baby.home_y = h.x, h.y
            newborn_rabbits.append(baby)
    rabbits.extend(newborn_rabbits)
    
    # Wolves reproduce near home when two FULL wolves are neighbors
    hx, hy = home_wolf_location[0].x, home_wolf_location[0].y
    newborn_wolves = []
    used = set()

    for i in range(len(wolfs)):
        if i in used:
            continue
        w1 = wolfs[i]

        # must be full and in home zone
        if w1.food_counter < food_counter_wolf:
            continue
        if abs(w1.x - hx) + abs(w1.y - hy) > Home_wolf_size:
            continue

        # find partner
        for j in range(i + 1, len(wolfs)):
            if j in used:
                continue
            w2 = wolfs[j]

            if w2.food_counter < food_counter_wolf:
                    continue
            if abs(w2.x - hx) + abs(w2.y - hy) > Home_wolf_size:
                continue

            # meet = neighbor 
            if abs(w1.x - w2.x) + abs(w1.y - w2.y) <= Pack_radius:
                # parents spend food to reproduce
                w1.food_counter -= food_counter_wolf
                w2.food_counter -= food_counter_wolf

                bx, by = random.randint(lower_wolf_house, upper_wolf_house), random.randint(lower_wolf_house, upper_wolf_house)
                newborn_wolves.append(wolf(bx, by))

                used.add(i)
                used.add(j)
                break

    wolfs.extend(newborn_wolves)     
    
    #starvation for wolfs
    wolfs = [w for w in wolfs if w.hunger < WOLF_STARVE_LIMIT]

    #animation
    plt.cla()
    ax = plt.gca()
    ax.set_title(f"Step: {frame} | wolfs: {len(wolfs)} | rabbits: {len(rabbits)}")
    ax.set_xlim(0, GRID_SIZE)
    ax.set_ylim(0, GRID_SIZE)
    ax.set_aspect('equal', adjustable='box') # Ensure squares appear as squares

    # Display images for humans and zombies
    for w in wolfs:
        ax.imshow(wolf_img, extent=[w.x, w.x + 1, w.y, w.y + 1], origin='lower')
    for r in rabbits:
        ax.imshow(rabbit_img, extent=[r.x, r.x + 1, r.y, r.y + 1], origin='lower')
    for hw in home_wolf_location:
        ax.imshow(home_wolf_img, extent=[hw.x, hw.x + 1, hw.y, hw.y + 1], origin='lower')
    for hr in homes_rabbit:
        ax.imshow(home_rabbit_img, extent=[hr.x, hr.x + 1, hr.y, hr.y + 1], origin='lower')

    # We no longer need plt.scatter and legend for individual agents if using images
    # If you want a legend for the overall type, you'd add a dummy plot or custom legend.
    # For now, the images themselves represent the agents.
    from IPython.display import HTML

    fig = plt.figure(figsize=(6, 6))
    ani = animation.FuncAnimation(fig, update, frames=40, interval=50, cache_frame_data=False)
    HTML(ani.to_jshtml())
    